"""
NGINX Configuration Generator
Dynamically creates NGINX configurations for frontend + backend deployments.
"""

import os
from pathlib import Path
from typing import Dict, Optional
from string import Template


class NginxConfigGenerator:
    """
    Generates NGINX configuration files for full-stack applications.
    """
    
    # NGINX config template for combined frontend + backend
    NGINX_TEMPLATE = """
# Generated by Alterion Panel
# Project: ${project_name}
# Generated: ${timestamp}

server {
    listen 80;
    server_name ${domain};
    
    ${ssl_redirect}
    
    # Frontend static files
    root ${frontend_path};
    index index.html;
    
    # Backend API proxy
    location /api/ {
        proxy_pass http://127.0.0.1:${backend_port}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $$host;
        proxy_set_header X-Real-IP $$remote_addr;
        proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $$scheme;
        proxy_cache_bypass $$http_upgrade;
        
        # CORS headers (optional)
        ${cors_headers}
    }
    
    # WebSocket support (if needed)
    ${websocket_config}
    
    # Frontend SPA fallback
    location / {
        try_files $$uri $$uri/ /index.html;
        
        # Cache control for static assets
        location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml text/javascript;
    
    # Max upload size
    client_max_body_size ${max_upload_size};
}

${ssl_server_block}
"""
    
    SSL_SERVER_BLOCK_TEMPLATE = """
server {
    listen 443 ssl http2;
    server_name ${domain};
    
    # SSL certificates
    ssl_certificate ${ssl_cert_path};
    ssl_certificate_key ${ssl_key_path};
    
    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # Frontend static files
    root ${frontend_path};
    index index.html;
    
    # Backend API proxy
    location /api/ {
        proxy_pass http://127.0.0.1:${backend_port}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $$host;
        proxy_set_header X-Real-IP $$remote_addr;
        proxy_set_header X-Forwarded-For $$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $$scheme;
        proxy_cache_bypass $$http_upgrade;
        
        # CORS headers (optional)
        ${cors_headers}
    }
    
    # WebSocket support (if needed)
    ${websocket_config}
    
    # Frontend SPA fallback
    location / {
        try_files $$uri $$uri/ /index.html;
        
        # Cache control for static assets
        location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml text/javascript;
    
    # Max upload size
    client_max_body_size ${max_upload_size};
}
"""
    
    def __init__(self, nginx_sites_available: str = "/etc/nginx/sites-available",
                 nginx_sites_enabled: str = "/etc/nginx/sites-enabled"):
        """
        Initialize NGINX config generator.
        
        Args:
            nginx_sites_available: Path to NGINX sites-available directory
            nginx_sites_enabled: Path to NGINX sites-enabled directory
        """
        self.sites_available = Path(nginx_sites_available)
        self.sites_enabled = Path(nginx_sites_enabled)
    
    def generate_config(self, 
                       project_name: str,
                       domain: str,
                       frontend_path: str,
                       backend_port: int = 8000,
                       ssl_enabled: bool = False,
                       ssl_cert_path: str = "",
                       ssl_key_path: str = "",
                       enable_websocket: bool = False,
                       enable_cors: bool = False,
                       max_upload_size: str = "10M") -> str:
        """
        Generate NGINX configuration for a project.
        
        Args:
            project_name: Name of the project
            domain: Domain name
            frontend_path: Absolute path to frontend dist folder
            backend_port: Backend server port
            ssl_enabled: Whether to enable SSL
            ssl_cert_path: Path to SSL certificate
            ssl_key_path: Path to SSL private key
            enable_websocket: Whether to enable WebSocket support
            enable_cors: Whether to enable CORS
            max_upload_size: Maximum upload size
            
        Returns:
            Generated NGINX configuration string
        """
        from datetime import datetime
        
        # SSL redirect if SSL is enabled
        ssl_redirect = ""
        if ssl_enabled:
            ssl_redirect = "return 301 https://$server_name$request_uri;"
        
        # CORS headers
        cors_headers = ""
        if enable_cors:
            cors_headers = """
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
        
        if ($request_method = OPTIONS) {
            return 204;
        }
            """
        
        # WebSocket configuration
        websocket_config = ""
        if enable_websocket:
            websocket_config = """
    location /ws/ {
        proxy_pass http://127.0.0.1:""" + str(backend_port) + """/ws/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
            """
        
        # SSL server block
        ssl_server_block = ""
        if ssl_enabled and ssl_cert_path and ssl_key_path:
            ssl_template = Template(self.SSL_SERVER_BLOCK_TEMPLATE)
            ssl_server_block = ssl_template.substitute(
                domain=domain,
                frontend_path=frontend_path,
                backend_port=backend_port,
                ssl_cert_path=ssl_cert_path,
                ssl_key_path=ssl_key_path,
                cors_headers=cors_headers,
                websocket_config=websocket_config,
                max_upload_size=max_upload_size
            )
        
        # Generate main config
        template = Template(self.NGINX_TEMPLATE)
        config = template.substitute(
            project_name=project_name,
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            domain=domain,
            frontend_path=frontend_path,
            backend_port=backend_port,
            ssl_redirect=ssl_redirect,
            cors_headers=cors_headers,
            websocket_config=websocket_config,
            ssl_server_block=ssl_server_block,
            max_upload_size=max_upload_size
        )
        
        return config
    
    def write_config(self, domain: str, config: str) -> str:
        """
        Write NGINX config to sites-available.
        
        Args:
            domain: Domain name (used as filename)
            config: NGINX configuration content
            
        Returns:
            Path to written config file
        """
        config_file = self.sites_available / domain
        
        # Create directory if it doesn't exist
        self.sites_available.mkdir(parents=True, exist_ok=True)
        
        # Write config
        with open(config_file, 'w') as f:
            f.write(config)
        
        return str(config_file)
    
    def enable_site(self, domain: str) -> bool:
        """
        Enable site by creating symlink in sites-enabled.
        
        Args:
            domain: Domain name
            
        Returns:
            True if successful
        """
        source = self.sites_available / domain
        target = self.sites_enabled / domain
        
        if not source.exists():
            raise FileNotFoundError(f"Config file not found: {source}")
        
        # Create sites-enabled directory if it doesn't exist
        self.sites_enabled.mkdir(parents=True, exist_ok=True)
        
        # Remove existing symlink if present
        if target.exists() or target.is_symlink():
            target.unlink()
        
        # Create symlink
        target.symlink_to(source)
        
        return True
    
    def disable_site(self, domain: str) -> bool:
        """
        Disable site by removing symlink from sites-enabled.
        
        Args:
            domain: Domain name
            
        Returns:
            True if successful
        """
        target = self.sites_enabled / domain
        
        if target.exists() or target.is_symlink():
            target.unlink()
            return True
        
        return False
    
    def test_config(self) -> Dict:
        """
        Test NGINX configuration syntax.
        
        Returns:
            Dict with test results
        """
        import subprocess
        
        result = {
            'success': False,
            'output': '',
            'error': ''
        }
        
        try:
            # Run nginx -t to test configuration
            process = subprocess.run(
                ['nginx', '-t'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            result['output'] = process.stdout
            result['error'] = process.stderr
            result['success'] = process.returncode == 0
        
        except subprocess.TimeoutExpired:
            result['error'] = "NGINX config test timed out"
        
        except FileNotFoundError:
            result['error'] = "NGINX executable not found"
        
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def reload_nginx(self) -> Dict:
        """
        Reload NGINX to apply configuration changes.
        
        Returns:
            Dict with reload results
        """
        import subprocess
        
        result = {
            'success': False,
            'output': '',
            'error': ''
        }
        
        try:
            # Run nginx -s reload
            process = subprocess.run(
                ['nginx', '-s', 'reload'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            result['output'] = process.stdout
            result['error'] = process.stderr
            result['success'] = process.returncode == 0
        
        except subprocess.TimeoutExpired:
            result['error'] = "NGINX reload timed out"
        
        except FileNotFoundError:
            result['error'] = "NGINX executable not found"
        
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def remove_config(self, domain: str) -> bool:
        """
        Remove NGINX configuration for a domain.
        
        Args:
            domain: Domain name
            
        Returns:
            True if successful
        """
        # Disable site first
        self.disable_site(domain)
        
        # Remove config file
        config_file = self.sites_available / domain
        if config_file.exists():
            config_file.unlink()
            return True
        
        return False
    
    def generate_ssl_config_for_letsencrypt(self, domain: str, email: str) -> Dict:
        """
        Generate Let's Encrypt SSL certificate configuration.
        
        Args:
            domain: Domain name
            email: Email for Let's Encrypt notifications
            
        Returns:
            Dict with SSL configuration info
        """
        return {
            'domain': domain,
            'email': email,
            'certbot_command': f'certbot --nginx -d {domain} --email {email} --agree-tos --non-interactive',
            'cert_path': f'/etc/letsencrypt/live/{domain}/fullchain.pem',
            'key_path': f'/etc/letsencrypt/live/{domain}/privkey.pem',
            'renewal_info': 'Certificates auto-renew every 60 days via certbot timer'
        }
